{"ast":null,"code":"// src/middleware/authMiddleware.js\nconst express = require('express');\nconst router = express.Router();\nconst cors = require('cors');\nconst bcrypt = require('bcryptjs');\nconst jwt = require('jsonwebtoken');\nconst User = require('../models/User');\n\n// Protect middleware: used to secure your routes\nconst protect = async (req, res, next) => {\n  let token;\n  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {\n    token = req.headers.authorization.split(' ')[1];\n    console.log(\"[DEBUG] protect - Retrieved token:\", token);\n    try {\n      // Verify token\n      const decoded = jwt.verify(token, process.env.JWT_SECRET);\n      console.log(\"[DEBUG] protect - Decoded token:\", decoded);\n\n      // Find user by ID from token payload\n      const user = await User.findById(decoded.userId).select('-password');\n      console.log(\"[DEBUG] protect - Fetched user from DB:\", user);\n      if (!user) {\n        return res.status(401).json({\n          message: 'User not found'\n        });\n      }\n      req.user = user;\n      next();\n    } catch (error) {\n      console.error(\"[DEBUG] protect - Error in authentication:\", error);\n      if (error.name === 'TokenExpiredError') {\n        return res.status(401).json({\n          message: 'Session expired. Please log in again.'\n        });\n      }\n      return res.status(401).json({\n        message: 'Not authorized, token failed'\n      });\n    }\n  } else {\n    return res.status(401).json({\n      message: 'Not authorized, no token'\n    });\n  }\n};\n\n// ========================\n// Authentication Routes\n// ========================\n\n// Register Route\nrouter.post('/register', async (req, res) => {\n  try {\n    const {\n      username,\n      password,\n      role\n    } = req.body;\n\n    // Check if username already exists\n    const existingUser = await User.findOne({\n      username\n    });\n    if (existingUser) {\n      return res.status(400).json({\n        message: 'Username already exists'\n      });\n    }\n\n    // Hash the password before saving\n    const salt = await bcrypt.genSalt(10);\n    const hashedPassword = await bcrypt.hash(password, salt);\n    const newUser = new User({\n      username,\n      password: hashedPassword,\n      role\n    });\n    await newUser.save();\n    res.status(201).json({\n      message: 'User created successfully'\n    });\n  } catch (error) {\n    console.error('Error in registration:', error);\n    res.status(500).json({\n      message: 'Internal server error',\n      error: error.message\n    });\n  }\n});\n\n// Login Route\nrouter.post('/login', async (req, res) => {\n  try {\n    const {\n      username,\n      password\n    } = req.body;\n    const user = await User.findOne({\n      username\n    });\n    if (!user) {\n      return res.status(401).json({\n        message: 'Invalid username or password',\n        statusCode: 401\n      });\n    }\n\n    // Compare hashed passwords\n    const isMatch = await bcrypt.compare(password, user.password);\n    if (!isMatch) {\n      return res.status(401).json({\n        message: 'Invalid username or password',\n        statusCode: 401\n      });\n    }\n\n    // Sign token with a 2-hour expiration\n    const token = jwt.sign({\n      userId: user._id,\n      username: user.username,\n      role: user.role\n    }, process.env.JWT_SECRET, {\n      expiresIn: '2h'\n    });\n    res.status(200).json({\n      token,\n      username: user.username,\n      role: user.role,\n      statusCode: 200\n    });\n  } catch (error) {\n    console.error('Error in login:', error);\n    res.status(500).json({\n      message: 'Internal server error',\n      error: error.message,\n      statusCode: 500\n    });\n  }\n});\n\n// Verify Token Route\nrouter.post('/verify-token', async (req, res) => {\n  try {\n    const {\n      token\n    } = req.body;\n    if (!token) {\n      return res.status(401).json({\n        message: 'No token provided'\n      });\n    }\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    res.status(200).json({\n      message: 'Token is valid',\n      userId: decoded.userId\n    });\n  } catch (error) {\n    console.error('Error in token verification:', error);\n    if (error.name === 'JsonWebTokenError') {\n      res.status(401).json({\n        message: 'Invalid token',\n        error: error.message\n      });\n    } else {\n      res.status(500).json({\n        message: 'Internal server error',\n        error: error.message\n      });\n    }\n  }\n});\n\n// Logout Route\nrouter.post('/logout', async (req, res) => {\n  try {\n    // Optionally perform cleanup or logging here.\n    res.status(200).json({\n      message: 'Logged out successfully'\n    });\n  } catch (error) {\n    console.error('Error during logout:', error);\n    res.status(500).json({\n      message: 'Internal server error'\n    });\n  }\n});\n\n// Attach the protect middleware as a property on the router so that it can be used elsewhere.\nrouter.protect = protect;\nmodule.exports = router;","map":{"version":3,"names":["express","require","router","Router","cors","bcrypt","jwt","User","protect","req","res","next","token","headers","authorization","startsWith","split","console","log","decoded","verify","process","env","JWT_SECRET","user","findById","userId","select","status","json","message","error","name","post","username","password","role","body","existingUser","findOne","salt","genSalt","hashedPassword","hash","newUser","save","statusCode","isMatch","compare","sign","_id","expiresIn","module","exports"],"sources":["/Users/ahmad/clock-in-out 2/client/src/redux/authActions.js"],"sourcesContent":["// src/middleware/authMiddleware.js\nconst express = require('express');\nconst router = express.Router();\nconst cors = require('cors');\nconst bcrypt = require('bcryptjs');\nconst jwt = require('jsonwebtoken');\nconst User = require('../models/User');\n\n// Protect middleware: used to secure your routes\nconst protect = async (req, res, next) => {\n  let token;\n\n  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {\n    token = req.headers.authorization.split(' ')[1];\n    console.log(\"[DEBUG] protect - Retrieved token:\", token);\n\n    try {\n      // Verify token\n      const decoded = jwt.verify(token, process.env.JWT_SECRET);\n      console.log(\"[DEBUG] protect - Decoded token:\", decoded);\n\n      // Find user by ID from token payload\n      const user = await User.findById(decoded.userId).select('-password');\n      console.log(\"[DEBUG] protect - Fetched user from DB:\", user);\n\n      if (!user) {\n        return res.status(401).json({ message: 'User not found' });\n      }\n\n      req.user = user;\n      next();\n    } catch (error) {\n      console.error(\"[DEBUG] protect - Error in authentication:\", error);\n      if (error.name === 'TokenExpiredError') {\n        return res.status(401).json({ message: 'Session expired. Please log in again.' });\n      }\n      return res.status(401).json({ message: 'Not authorized, token failed' });\n    }\n  } else {\n    return res.status(401).json({ message: 'Not authorized, no token' });\n  }\n};\n\n// ========================\n// Authentication Routes\n// ========================\n\n// Register Route\nrouter.post('/register', async (req, res) => {\n  try {\n    const { username, password, role } = req.body;\n\n    // Check if username already exists\n    const existingUser = await User.findOne({ username });\n    if (existingUser) {\n      return res.status(400).json({ message: 'Username already exists' });\n    }\n\n    // Hash the password before saving\n    const salt = await bcrypt.genSalt(10);\n    const hashedPassword = await bcrypt.hash(password, salt);\n\n    const newUser = new User({\n      username,\n      password: hashedPassword,\n      role,\n    });\n\n    await newUser.save();\n    res.status(201).json({ message: 'User created successfully' });\n  } catch (error) {\n    console.error('Error in registration:', error);\n    res.status(500).json({ message: 'Internal server error', error: error.message });\n  }\n});\n\n// Login Route\nrouter.post('/login', async (req, res) => {\n  try {\n    const { username, password } = req.body;\n\n    const user = await User.findOne({ username });\n    if (!user) {\n      return res.status(401).json({ \n        message: 'Invalid username or password', \n        statusCode: 401 \n      });\n    }\n\n    // Compare hashed passwords\n    const isMatch = await bcrypt.compare(password, user.password);\n    if (!isMatch) {\n      return res.status(401).json({ \n        message: 'Invalid username or password', \n        statusCode: 401 \n      });\n    }\n\n    // Sign token with a 2-hour expiration\n    const token = jwt.sign(\n      { userId: user._id, username: user.username, role: user.role },\n      process.env.JWT_SECRET,\n      { expiresIn: '2h' }\n    );\n\n    res.status(200).json({ \n      token, \n      username: user.username, \n      role: user.role,\n      statusCode: 200 \n    });\n  } catch (error) {\n    console.error('Error in login:', error);\n    res.status(500).json({ \n      message: 'Internal server error', \n      error: error.message,\n      statusCode: 500 \n    });\n  }\n});\n\n// Verify Token Route\nrouter.post('/verify-token', async (req, res) => {\n  try {\n    const { token } = req.body;\n\n    if (!token) {\n      return res.status(401).json({ message: 'No token provided' });\n    }\n\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    res.status(200).json({ message: 'Token is valid', userId: decoded.userId });\n  } catch (error) {\n    console.error('Error in token verification:', error);\n    if (error.name === 'JsonWebTokenError') {\n      res.status(401).json({ message: 'Invalid token', error: error.message });\n    } else {\n      res.status(500).json({ message: 'Internal server error', error: error.message });\n    }\n  }\n});\n\n// Logout Route\nrouter.post('/logout', async (req, res) => {\n  try {\n    // Optionally perform cleanup or logging here.\n    res.status(200).json({ message: 'Logged out successfully' });\n  } catch (error) {\n    console.error('Error during logout:', error);\n    res.status(500).json({ message: 'Internal server error' });\n  }\n});\n\n// Attach the protect middleware as a property on the router so that it can be used elsewhere.\nrouter.protect = protect;\n\nmodule.exports = router;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}